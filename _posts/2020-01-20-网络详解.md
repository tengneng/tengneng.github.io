---
layout:     post   				    # 使用的布局（不需要改）
title:      网络详解				# 标题 
#subtitle:   Hello World, Hello Blog #副标题
date:       2020-01-20				# 时间
author:     Teng 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 网络
---
## 网络详解
### OSI七层模型

    应用层 ：为应用程序提供服务，并管理应用程序之间的通信（SMTP、HTTP、FTP）

    表示层 ：处理数据的标识问题，比如编码、格式转化、加密解密等

    会话层 ：负责建立管理和断开通信连接，实现数据同步

    传输层 ：端到端传输数据，同时处理传输错误、控制流量等（TCP UDP）

    网络层 ：地址管理、路由选择（IP协议）（路由器）

    数据链路层 ：数据分割成帧，mac寻址、差错校验、信息纠正等。（以太网）（交换机）

    物理层 ：利用传输介质为数据链路层提供物理连接

发送端从应用层 → 物理层 打包发送

接收层从物理层 → 应用层 解析获取

![67.PNG](https://i.loli.net/2020/02/29/JgcT9GoPH1KLNhd.png)

### 从输入一个URL到页面渲染的流程

    一、DNS解析URL的过程
    二、浏览器发送请求与服务器交互的过程
    三、浏览器对接收到的html页面渲染的过程

#### 1.DNS解析URL的过程
（1）首先会在浏览器的缓存中查找，是否缓存了URL，如果有，就直接向该URL对应的服务器发送请求；如果没有则进行下一步;

（2）在操作系统缓存hosts文件中查询是否保存了该URL和其对应的IP地址，如果保存了，就直接向该URL对应的服务器发送请求；如果没有则进行下一步；

（3）路由器缓存。路由器也有DNS缓存，以上三步都为客户机缓存。

（4）向本地DNS服务器（一般由本地网络接入服务器提供商提供，比如移动）发送DNS请求。本地DNS服务器会首先查询它的缓存记录，如果有就将该域名对应的IP地址返回给用户，如果没有则进行下一步；

（5）首先向根域名服务器发送DNS查询请求，根域名服务器返回给可能保存了该域名的一级域名服务器地址；本地主机再根据返回的地址，向一级域名服务器发送DNS查询请求；...一直迭代，直到找到对应的域名存放的服务器，向其发送DNS查询请求，该域名服务器返回该域名对应的IP地址；

![1490755-20190422152442534-1817063305.png](https://i.loli.net/2020/02/29/ct6TKC52MJeGh8i.png)

#### 2.浏览器与服务器交互过程
（1）首先浏览器利用tcp协议通过三次握手与服务器建立连接；

（2）浏览器根据解析到的IP地址和端口号发起http的get请求；

（3）服务器接收到http请求之后，开始搜索html页面，返回html文件；

（4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染；

#### 3.浏览器渲染过程
（1）解析html,生成DOM树；

（2）解析css，生成CSSOM树；

（3）合并DOM树和CSSOM树，生成Render树；

（4）JS根据得到的render树，计算所有节点在屏幕中的位置，进行布局（回流）；

（5）遍历render树并调用硬件API绘制所有节点（重绘）；

#### 4.TCP断开连接，四次挥手

### TCP与UDP

UDP协议是面向无连接的，不需要在正式传递数据之前先连接起对方。UDP协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP协议也没有任何控制流量的算法，总的来说UDP相较于TCP更加轻便。一般用于直播、即时通讯、即时游戏等。

TCP 无论是建立连接还是断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。

### http请求中connection=keep-alive的意义
HTTP 是基于 TCP 的，每一个 HTTP 请求都需要进行三次握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0 中出现了Connection: keep-alive，用于建立长连接。Keep-Alive 模式更加高效，因为避免了连接建立和释放的开销。但是，长时间的TCP连接容易导致系统资源无效占用，配置不当的keep-alive有时比重复利用连接带来的损失还更大。所以，正确设置keep-alive timeout时间非常重要。

所谓短连接，就是每次请求一个资源就建立连接，请求完成后连接立马关闭。每次请求都经过“创建tcp连接->请求资源->响应资源->释放连接”这样的过程。

所谓长连接(persistent connection)，就是只建立一次连接，多次资源请求都复用该连接，完成后关闭。要请求一个页面上的十张图，只需要建立一次tcp连接，然后依次请求十张图，等待资源响应，释放连接。

### http1.0和http2.0的区别
http2.0是对http1.0的改进，相较于http1.0更快更高效

1.http2.0实现了多路复用，用一个TCP进行连接共享，一个请求对应一个id，这样就可以发送多个请求，接收方通过id来响应不同的请求，解决了http1.0队首阻塞和连接过多的问题。因为http2.0在同一域名不论访问多少文件都只有一个连接，所以对服务器而言，提升的并发量是很大的。

2.http2.0引入了二进制数据帧和流的概念，数据拆分成数据帧传输，并进行顺序标识，接收方收到数据后按序组合即可获取正确数据。这样就可以并行传输了，解决了http1.0只能串行传输的问题。

3.http2.0压缩头部，使用序号对头部编码，在两端备份索引表，通过对编码进行比较来判断是否需要传输，减少了需要传输的大小。解决了http1.0中头部反复传输资源浪费的问题。

4.http2.0中，服务器可以在客户端某个请求后，主动推送一些客户端一定需要的资源。这样也能减少请求的数目。

新特性

多路复用

通过一个TCP连接传输所有数据。一个请求对应一个id，这样一个链接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的id将请求再归属到各自不同的服务器端请求里面

二进制分帧层

HTTP/2.0性能增强的关键，它改变了通信两端交互数据的方式，原先是以文本传输，现在要先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对方接受帧并拼接成一条消息，再处理请求

首部压缩

前面提到过的HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小

服务器推送

HTTP2.0支持服务器主动推送，简单地说就是一次请求返回多个响应，这也是一减少HTTP请求的方法。服务器除了处理最初的请求外，还会额外push客户端一定会请求的资源，无需客户端发出明确的请求。

存在问题

http2.0使用了多路复用，一般来说同一域名下只需要使用一个TCP连接。但是当连接中出现丢包时，整个TCP都要开始等待重传，后面的数据也都被阻塞了。而http1.0可以开启多个连接，只会影响一个，不会影响其他的。所以在丢包情况下，http2.0的情况反而不如http1.0。




