---
layout:     post   				    # 使用的布局（不需要改）
title:      TCP三次握手与四次挥手				# 标题 
#subtitle:   Hello World, Hello Blog #副标题
date:       2020-01-01				# 时间
author:     Teng 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 网络
---
## TCP三次握手与四次挥手

### 三次握手
![img1](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 四次挥手
![img2](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

SYN:代表请求创建连接，SYN这个标志位只有在TCP建立连接时才会被置1，握手完成后被置0。

ACK:代表确认接受，不管是三次握手还是四次分手，在回应的时候都会加上ACK=1，表示消息接收到了，并且在建立连接以后的发送数据时，都需加上ACK=1,来表示数据接收成功。

FIN:表示请求关闭连接，在四次挥手时，FIN发了两遍，这是因为TCP的连接是双向的，一次FIN只能关闭一个方向。

seq:序列号，当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。初始序列号是随机生成的。

ack:期待收到对方下一个数据包的编号。

### 总结：

在创建连接时，

    1.客户端首先发送SYN包，表示要创建连接。客户端进入SYN_SEND状态等待服务器确认。
    2.服务端接收到后，告诉客户端：我接受到了。同时向客户端发送一个SYN包，即SYN+ACK包。此时服务器进入SYN_RECV状态。
    3.为了防止意外，客户端要再发确认包ACK给服务端。客户端和服务端进入ESTABLISHED状态。

在四次挥手时，
    
    1.首先客户端请求关闭客户端到服务端方向的连接，客户端发送FIN=1。
    2.服务端接受后确认，发送ACK=1。
    3.此时只关闭了一个方向，另一个方向也需要关闭，服务端向客户端发送FIN=1,ACK=1。
    4.客户端接收到后发送ACK=1，接收成功。

### 疑问：

    1.三次握手中，为什么客户机最后还要再向服务器发送一次确认呢？
    答：这是为了防止已失效的连接请求突然又传到了服务器。当出现一种异常情况，即客户机发出的第一个报文段并没有丢失，而是在某个节点上长时间滞留了，直至客户机向服务器发送了第二个报文段并且已经完成了数据传输释放了连接，此时死一个报文到达服务器后被误认为是客户机重新发起的一次连接请求，实质上是一个早已失效的连接请求。如果没有第三次握手，那么这个连接就建立了，但是客户机并不会向服务器发送任何请求，连接就会一直持续着，消耗网络资源。
    
    2.为什么需要四次挥手？
    答：TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。




